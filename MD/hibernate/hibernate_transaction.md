## Hibernate中的事务与并发

#### **事务相关的概念**

1. 什么是事务
    * 事务就是逻辑上的一组操作，组成事务的各个执行单元，操作要么全都成功，要么全都失败.
    * 转账的例子：冠希给美美转钱，扣钱，加钱。两个操作组成了一个事情！

2. 事务的特性
    * 原子性   -- 事务不可分割.
    * 一致性   -- 事务执行的前后数据的完整性保持一致.
    * 隔离性   -- 一个事务执行的过程中,不应该受到其他的事务的干扰.
    * 持久性   -- 事务一旦提交,数据就永久保持到数据库中.

3. 如果不考虑隔离性:引发一些读的问题
    * 脏读            -- 一个事务读到了另一个事务未提交的数据.
    * 不可重复读 -- 一个事务读到了另一个事务已经提交的update数据,导致多次查询结果不一致.
    * 虚读            -- 一个事务读到了另一个事务已经提交的insert数据,导致多次查询结构不一致.

4. 通过设置数据库的隔离级别来解决上述读的问题
    * 未提交读:以上的读的问题都有可能发生.
    * 已提交读:避免脏读,但是不可重复读，虚读都有可能发生.
    * 可重复读:避免脏读，不可重复读.但是虚读是有可能发生.
    * 串行化:以上读的情况都可以避免.

5. 如果想在Hibernate的框架中来设置隔离级别，需要在hibernate.cfg.xml的配置文件中通过标签来配置
    * 通过：hibernate.connection.isolation = 4 来配置
    * 取值
        * 1—Read uncommitted isolation
        * 2—Read committed isolation
        * 4—Repeatable read isolation
        * 8—Serializable isolation

#### **丢失更新的问题**

1. 如果不考虑隔离性，也会产生写入数据的问题，这一类的问题叫丢失更新的问题。
2. 例如：两个事务同时对某一条记录做修改，就会引发丢失更新的问题。
    * A事务和B事务同时获取到一条数据，同时再做修改
    * 如果A事务修改完成后，提交了事务
    * B事务修改完成后，不管是提交还是回滚，如果不做处理，都会对数据产生影响

3. 解决方案有两种
    * 悲观锁
        * 采用的是数据库提供的一种锁机制，如果采用做了这种机制，在SQL语句的后面添加 for update 子句
            * 当A事务在操作该条记录时，会把该条记录锁起来，其他事务是不能操作这条记录的。
            * 只有当A事务提交后，锁释放了，其他事务才能操作该条记录

    * 乐观锁
        * 采用版本号的机制来解决的。会给表结构添加一个字段version=0，默认值是0
            * 当A事务在操作完该条记录，提交事务时，会先检查版本号，如果发生版本号的值相同时，才可以提交事务。同时会更新版本号version=1.
            * 当B事务操作完该条记录时，提交事务时，会先检查版本号，如果发现版本不同时，程序会出现错误。

4. 使用Hibernate框架解决丢失更新的问题
    * 悲观锁
        * 使用session.get(Customer.class, 1,LockMode.UPGRADE); 方法

    * 乐观锁
        * 1.在对应的JavaBean中添加一个属性，名称可以是任意的。例如：private Integer version; 提供get和set方法
        * 2.在映射的配置文件中，提供<version name="version"/>标签即可。

