## 数据库隔离级别 脏读 幻读 ACID mysql的隔离级别
**数据库隔离级别**：

	**SERIALIZABLE（串行化）**：当数据库系统使用SERIALIZABLE隔离级别时，一个事务在执行过程中完全看不到其他事务对数据库所做的更新。当两个事务同时操作数据库中相同数据时，如果第一个事务已经在访问该数据，第二个事务只能停下来等待，必须等到第一个事务结束后才能恢复运行。因此这两个事务实际上是串行化方式运行。

	**REPEATABLE READ（可重复读）**：当数据库系统使用REPEATABLE READ隔离级别时，一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，但是不能看到其他事务对已有记录的更新。

	**READ COMMITTED（读已提交数据）**：当数据库系统使用READ COMMITTED隔离级别时，一个事务在执行过程中可以看到其他事务已经提交的新插入的记录，而且还能看到其他事务已经提交的对已有记录的更新。

	**READ UNCOMMITTED（读未提交数据）**：当数据库系统使用READ UNCOMMITTED隔离级别时，一个事务在执行过程中可以看到其他事务没有提交的新插入的记录，而且还能看到其他事务没有提交的对已有记录的更新。

**ACID:**

- Atomicity（原子性）：一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被恢复（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。
- Consistency（一致性）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。
- Isolation（隔离性）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。
- Durability（持久性）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。

**脏读 ，不可重复读，幻读：**

脏读：读到未提交更新的数据

|            事务A            |             事务B              |
| :-------------------------: | :----------------------------: |
|                             |          **开始事务**          |
|        **开始事务**         |                                |
|                             |      查询账户余额为1000元      |
|                             |    取出500元把余额改为500元    |
| 查询账户余额为500元（脏读） |                                |
|                             | **撤销事务**，余额恢复为1000元 |
|  存入100元把余额改为600元   |                                |
|        **提交事务**         |                                |

不可重复读：读到已经提交更新的数据，但一个事务范围内两个相同的查询却返回了不同数据。

|                         事务A                         |          事务B           |
| :---------------------------------------------------: | :----------------------: |
|                                                       |       **开始事务**       |
|                     **开始事务**                      |                          |
|                                                       |   查询账户余额为1000元   |
|                 查询账户余额为1000元                  |                          |
|                                                       | 取出100元把余额改为900元 |
|                                                       |       **提交事务**       |
| 查询账户余额为900元（与T4读取的一不一致，不可重复读） |                          |

幻读：读到已提交插入数据，幻读与不可重复读类似，幻读是查询到了另一个事务已提交的新插入数据，而不可重复读是查询到了另一个事务已提交的更新数据。

|                           事务A                           |             事务B              |
| :-------------------------------------------------------: | :----------------------------: |
|                                                           |          **开始事务**          |
|                       **开始事务**                        |                                |
|                 统计用户Z总存款数为1000元                 |                                |
|                                                           | 新增Z的一个存款账号，存款100元 |
|                                                           |          **提交事务**          |
| 再次统计用户Z总存款数为1100元（与T4读取的一不一致，幻读） |                                |

**mysql的隔离级别：**

大多数关系数据库默认使用Read committed的隔离级别，Mysql InnoDB默认使用Read repeatable的隔离级别，这和Mysql replication 机制使用Statement日志格式有关。各数据库隔离级别的实现也是有差别的，例如Oracle支持Read committed 和Serializable两种隔离级别，另外可以通过使用读快照在Read committed级别上禁止不可重复读问题；

MySQL默认采用RR隔离级别，SQL标准是要求RR解决不可重复读的问题，但是因为MySQL采用了gap lock，所以实际上MySQL的RR隔离级别也解决了幻读的问题，也就是Mysql InnoDB在Read repeatable级别上使用next-key locking 策略来避免幻读现象的产生。