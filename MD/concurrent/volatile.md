# Volatile变量使用

volatile应该是Java虚拟机提供的最轻量级的同步机制。

一个变量被定义为volatile之后，将拥有两种特性：

1. 保证此变量对所有线程的可见性；
2. 禁止指令重排序优化。

## “可见性“的陷阱

关于volatile的可见性，有以下误解：

> “volatile变量对所有线程是立即可见的，对volatile变量的所有写操作都能理解反应到其他所有线程中，换句话说volatile变量在各个线程中是一致的，所以基于 volatile变量的运算在井发下是安全的”。

这句话的论据部分并没有错，但是其论据并不能得出“基于 Volatile变量的运算在并发下是安全的”这个结论。 

volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中， volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新执行引看不到不一致的情况，因此可以认为不存在一致性间题），但是Java里面的运算并非原子操作，导致 volatile变量的运算在并发下一样是不安全的。

由于volatile变量只能保证可见性，在不符合以下两条规则的运算场景中，我们仍要通过加锁（使用synchronized或concurrent中的原子类）来保证原子性。

- 运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值

- 变量并不需要与其他的状态变量共同参与不变约束。



