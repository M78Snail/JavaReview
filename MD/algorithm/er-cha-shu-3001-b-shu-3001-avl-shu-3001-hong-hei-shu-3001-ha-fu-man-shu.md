## **二叉树** {#toc_2}

二叉树（Binary tree）是每个节点最多有两个子树的树结构。二叉树的子树有左右之分，次序不能颠倒。

二叉树的第i层至多有 这里写图片描述个结点； 深度为k的二叉树至多共有这里写图片描述个结点；对任何一棵二叉树T，如果其终端结点数为这里写图片描述，度为2的节点数为 这里写图片描述，则 这里写图片描述。

与树不同，树的节点个数至少为1，而二叉树的节点个数可以为0；树中节点的最大度数没有限制，而二叉树节点的最大度数为2；树的节点无左、右之分，而二叉树的结点有左、右之分。

---

**B+树**

B+ 树是一种树数据结构，是一个**n叉树**，每个节点通常有多个孩子，一颗B+树包含**根节点**、**内部节点**和**叶子节点**。根节点可能是一个叶子节点，也可能是一个包含两个或两个以上孩子节点的节点。

B+ 树通常用于**数据库**和**操作系统的文件系统**中。NTFS, ReiserFS, NSS, XFS, JFS, ReFS 和BFS等文件系统都在使用B+树作为**元数据索引**。B+ 树的特点是能够保持**数据稳定有序**，其插入与修改拥有较稳定的对数时间复杂度。B+ 树元素自底向上插入。

---

**AVL树**

AVL树中任何节点的两个子树的高度最大差别为一，所以它也被称为高度平衡树。查找、插入和删除在平均和最坏情况下都是O（log n）。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。

节点的平衡因子是它的左子树的高度减去它的右子树的高度（有时相反）。带有平衡因子1、0或 -1的节点被认为是平衡的。带有平衡因子 -2或2的节点被认为是不平衡的，并需要重新平衡这个树。平衡因子可以直接存储在每个节点中，或从可能存储在节点中的子树高度计算出来。

---

**红黑树**

红黑树（Red Black Tree） 是一种自平衡二叉查找树，红黑树和AVL树类似，都是在进行插入和删除操作时通过特定操作保持二叉查找树的平衡，从而获得较高的查找性能。

它虽然是复杂的，但它的最坏情况运行时间也是非常良好的，并且在实践中是高效的： 它可以在O\(log n\)时间内做查找，插入和删除，这里的n 是树中元素的数目。[详情](https://github.com/Mr-YangCheng/ForAndroidInterview/blob/master/data structure/[数据结构] 红黑树.md)

---

**哈夫曼树**

哈夫曼树又称最优二叉树，是一种带权路径长度最短的二叉树。所谓树的带权路径长度，就是树中所有的叶结点的权值乘上其到根结点的 路径长度（若根结点为0层，叶结点到根结点的路径长度为叶结点的层数）。

树的带权路径长度记为WPL= \(W1L1+W2L2+W3L3+...+WnLn\)，N个权值Wi\(i=1,2,...n\)构成一棵有N个叶结点的二叉树，相应的叶结点的路径长度为Li\(i=1,2,...n\)。可以证明哈夫曼树的WPL是最小的。

**哈夫曼树的构造**

假设有n个权值，则构造出的哈夫曼树有n个叶子结点。 n个权值分别设为 w1、w2、…、wn，则哈夫曼树的构造规则为：

1. 将w1、w2、…，wn看成是有n 棵树的森林\(每棵树仅有一个结点\)；
2. 在森林中选出两个根结点的权值最小的树合并，作为一棵新树的左、右子树，且新树的根结点权值为其左、右子树根结点权值之和；

3. 从森林中删除选取的两棵树，并将新树加入森林；

4. 重复②、③步，直到森林中只剩一棵树为止，该树即为所求得的哈夫曼树。

**哈夫曼编码**  
哈夫曼编码是可变字长编码\(VLC\)的一种。该方法完全依据字符出现概率来构造异字头的平均长度最短的码字，有时称之为最佳编码。

> 有A,B,C,D,E五个字符，出现的频率（即权值）分别为5,4,3,2,1，对其进行哈夫曼编码。

首先把A,B,C,D,E构造成一棵哈夫曼树（２.１有说明）；

通过从哈夫曼树根结点开始，对左子树分配代码“0”，右子树分配代码“1”，一直到达叶子结点为止，然后将从树根沿每条路径到达叶子结点的代码排列起来，便得到了哈夫曼编码。

| ![](/assets/import4.6.png) |
| :---: |




