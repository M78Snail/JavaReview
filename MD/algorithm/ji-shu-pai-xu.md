> 基数排序（Radix sort）是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。
>
> 将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后，数列就变成一个有序序列。

**效率**

基数排序的时间复杂度是O\(k·n\)，其中n是排序元素个数，k是数字位数。注意这不是说这个时间复杂度一定优于O\(n·log\(n\)\)，k的大小取决于数字位的选择和待排序数据所属数据类型的全集的大小；k决定了进行多少轮处理，而n是每轮处理的操作数目。

基数排序基本操作的代价较小，k一般不大于logn，所以基数排序一般要快过基于比较的排序，比如快速排序。

最差空间复杂度是O\(k·n\)

现在有数组：278，109，63,930,589,184,505,269,8,83　。根据各位数将数组划分为10个链表\(当然其中的某些链表可能不含有元素\) 第一次分配：

**0:930 1: 2: 3:63,83 4:184 5:505 6： 7: 8:278,8 9:109,589,269**  
第一次收集后的数组：

**930,63,83,184,505，278,8,109,589,269**  
第二次分配：

**0:505,8,109 1: 2: 3:930 4: 5: 6：63,269 7:278 8:83,184，589 9:**  
第二次收集后的数组：

**505,8,109，930，63,269，278，83,184，589**  
第三次分配：

**0:8,63,83 1:109,184 2:278,269 3: 4: 5:505,589 6: 7: 8: 9:930**  
最后得到序列：

**8,63,83,109,184，269,278,505,589,930**  
基数排序其实是利用多关键字先达到局部有序，再调整达到全局有序。

**Java实现**

```java
public class Test {
    public static void main(String[] args) {

        int[] array = {278,109,63,930,589,184,505,269,8,83};  
        radixSort(array);  
        for(double a : array){
            System.out.println(a);
        }
    }
public static void radixSort(int[] array){
        
        //------------------------------------------确定排序的趟数----------------------------------
        int max=array[0];
        for(int i=1;i<array.length;i++){
            if(array[i]>max){
                max=array[i];
            }
        }
        int time=0;
        while(max>0){
            max/=10;
            time++;
        }
        //----------------------------------------初始化10个链表用户分配时暂存-------------------------------
        List<List<Integer>> list=new ArrayList<List<Integer>>();
        for(int i=0;i<10;i++){
            List<Integer> item=new ArrayList<Integer>();
            list.add(item);
        }
        
        //-----------------------------------------进行time次分配和收集-------------------------------------
      for(int i=0;i<time;i++){
            //分配元素;
            for(int j=0;j<array.length;j++){
                int index = array[j]%(int)Math.pow(10, i+1)/(int)Math.pow(10, i);
                list.get(index).add(array[j]);
            }
            //收集元素;
            int count=0;
            for(int k=0;k<10;k++){
                if(list.get(k).size()>0){
                    for(int a : list.get(k)){
                        array[count]=a;
                        count++;
                    }
                    //清除数据，以便下次收集
                    list.get(k).clear();
                }
            }
        }
    }
}
```



