### TCP三次握手过程

1. 主机A通过向主机B发送一个含有同步序列号的标志位的数据段给主机B,向主机B请求建立连接，通过这个数据段，主机A高速主机B两件事:我想要和你通信；你可以用那个序列号作为起始数据段来回应我。

2. 主机B收到主机A的请求后，用一个带有确认应答的\(ACK\)和同步序列\(SYN\)标志位的数据段响应主机A,也告诉主机A两件事：我已经收到你的请求了，你可以传输数据了；你要用那个序列号作为起始数据段来回应我。

3. 主机A收到这个数据段后，再发送一个确认应答\(ACK\),确认已收到主机B的数据段：我已收到回复,我现在要开始传输实际数据了 这样3次握手就完成了,主机A和主机B 就可以传输数据了。

---

### 3次握手的特点 

1. 没有应用层的数据  

2. SYN这个标志位只有在TCP建产连接时才会被置1  
3. 握手完成后SYN标志位被置0

---

### TCP建立连接要进行3次握手,而断开连接要进行4次 

1. 当主机A完成传输后，将控制位FIN置1，提出停止TCP连接的请求。

2. 主机B收到FIN后对其作出响应，确认这一方向上的TCP连接将关闭，将ACK置1

3. 由B端再提出反方向的关闭请求，将FIN置1

4. 主机A对主机B的请求进行确认，将ACK置1，双方向的关闭结束。

> 由TCP的三次握手和四次断开可以看出,TCP使用面向连接的通信方式,大大提高了数据通信的可靠性,使发送数据端 和接收端在数据正式传输前就有了交互,为数据正式传输打下了可靠的基础。

#### 为什么需要“四次挥手”  

那可能有人会有疑问，在tcp连接握手时为何ACK是和SYN一起发送，这里ACK却没有和FIN一起发送呢。原因是因为tcp是全双工模式，接收到FIN时意味将没有数据再发来，但是还是可以继续发送数据。

---

### 名词解释 

- **ACK**：TCP报头的控制位之一,对数据进行确认.确认由目的端发出,用它来告诉发送端这个序列号之前的数据段 都收到了.比如,确认号为X,则表示前X-1个数据段都收到了,只有当ACK=1时,确认号才有效,当ACK=0时,确认号无效,这时会要求重传数据,保证数据的完整性。  
- **SYN**：同步序列号,TCP建立连接时将这个位置1。  
- **FIN**：发送端完成发送任务位,当TCP完成数据传输需要断开时,提出断开连接的一方将这位置1。

客户端与服务器端建立TCP/IP连接后关闭SOCKET后，服务器端连接的端口 状态为TIME\_WAIT

---

### 是不是所有执行主动关闭的socket都会进入TIME\_WAIT状态呢？ 

#### 有没有什么情况使主动关闭的socket直接进入CLOSED状态呢？

主动关闭的一方在发送最后一个ack 后

就会进入TIME\_WAIT 状态 停留2MSL（max segment lifetime）时间

这个是TCP/IP必不可少的，也就是“解决”不了的。
也就是TCP/IP设计者本来是这么设计的

**主要有两个原因**

1. 防止上一次连接中的包，迷路后重新出现，影响新连接（经过2MSL，上一次连接中所有的重复包都会消失）
2. 可靠的关闭TCP连接，在主动关闭方发送的最后一个ACK\(fin\),有可能丢失,这时被动方会重新发fin,如果这时主动方处于CLOSED状态,就会响应rst而不是ACK。所以主动方要处于TIME\_WAIT状态，而不能是CLOSED。TIME\_WAIT并不会占用很大资源，除非受到攻击。还有，如果任何一方send或recv超时，就会直接进入CLOSED状态。

![](https://github.com/M78Snail/JavaReview/blob/master/MD/net/assets/import741.png) 


